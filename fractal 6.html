<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Fractal Attractor theo Độ sâu</title>
    
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            display: flex;
            justify-content: center;
            align-items: flex-start;
            padding: 20px;
            background-color: #1a1a1a;
            color: #f0f0f0;
            margin: 0;
            overflow: hidden;
        }
        .container {
            display: flex;
            gap: 30px;
            max-width: 1400px;
            width: 100%;
        }
        .info-panel {
            flex: 1;
            padding: 20px;
            background: #2c2c2c;
            border-radius: 8px;
            max-height: 90vh;
            overflow-y: auto;
        }
        #scene-container {
            flex: 2;
            height: 90vh;
            border-radius: 8px;
            overflow: hidden;
            background-color: #000;
        }
        h2 {
            color: #5cceee;
            border-bottom: 2px solid #555;
            padding-bottom: 10px;
        }
        p i { color: #aaa; }
        .controls {
            margin-top: 20px;
            padding-top: 20px;
            border-top: 1px solid #555;
        }
        .controls label {
            display: block;
            margin-bottom: 10px;
            font-weight: bold;
        }
        .controls input[type="range"] {
            width: 100%;
            cursor: pointer;
        }
        #depthValue {
            font-weight: bold;
            color: #5cceee;
        }
        #cubeCount { color: #ccc; font-style: italic; }
    </style>
</head>
<body>

<div class="container">
    <div class="info-panel">
        <h2>Fractal 3D Đệ quy</h2>
        <p>Hình ảnh được tạo bằng cách áp dụng đệ quy quy tắc "chia khối lập phương thành 4x4x4 và giữ lại 8 khối trung tâm". Mỗi nhánh đệ quy có một màu riêng.</p>
        <p><i>Kéo chuột trái để quay, lăn chuột để zoom, kéo chuột phải để di chuyển.</i></p>

        <div class="controls">
            <h2>Điều khiển</h2>
            <label for="depthSlider">Độ sâu (Depth): <span id="depthValue">3</span></label>
            <input type="range" id="depthSlider" min="1" max="5" step="1" value="3">
            <p id="cubeCount">Số khối: 512</p>
        </div>
    </div>

    <div id="scene-container"></div>
</div>

<!-- Tải thư viện Three.js và OrbitControls -->
<script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
        }
    }
</script>

<script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

    // --- CÀI ĐẶT CƠ BẢN ---
    const sceneContainer = document.getElementById('scene-container');
    const depthSlider = document.getElementById('depthSlider');
    const depthValueDisplay = document.getElementById('depthValue');
    const cubeCountDisplay = document.getElementById('cubeCount');
    let instancedMesh = null;

    // --- SCENE, CAMERA, RENDERER ---
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x101010);
    const camera = new THREE.PerspectiveCamera(75, sceneContainer.clientWidth / sceneContainer.clientHeight, 0.01, 1000);
    camera.position.set(0.8, 0.8, 0.8);
    
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(sceneContainer.clientWidth, sceneContainer.clientHeight);
    sceneContainer.appendChild(renderer.domElement);
    
    // --- CONTROLS ---
    const controls = new OrbitControls(camera, renderer.domElement);
    controls.target.set(0.5, 0.5, 0.5);
    controls.enableDamping = true;

    // --- LIGHTING ---
    scene.add(new THREE.AmbientLight(0xffffff, 0.8));
    const directionalLight = new THREE.DirectionalLight(0xffffff, 1.2);
    directionalLight.position.set(3, 5, 4);
    scene.add(directionalLight);

    // --- ĐỊNH NGHĨA 8 PHÉP BIẾN ĐỔI VÀ MÀU SẮC ---
    const transformations = [];
    const colors = [
        new THREE.Color("#0077b6"), // Xanh dương
        new THREE.Color("#d62828"), // Đỏ
        new THREE.Color("#6a0dad"), // Tím
        new THREE.Color("#f77f00"), // Cam
        new THREE.Color("#00a651"), // Xanh lá
        new THREE.Color("#f9c74f"), // Vàng
        new THREE.Color("#ef476f"), // Hồng
        new THREE.Color("#2ec4b6"), // Xanh ngọc
    ];
    
    for (let i = 0; i < 2; i++) {
        for (let j = 0; j < 2; j++) {
            for (let k = 0; k < 2; k++) {
                const translation = new THREE.Vector3(i / 4 + 0.25, j / 4 + 0.25, k / 4 + 0.25);
                transformations.push(translation);
            }
        }
    }
    
    // --- HÀM TẠO FRACTAL ---
    function generateFractal(maxDepth) {
        if (instancedMesh) {
            scene.remove(instancedMesh);
            instancedMesh.geometry.dispose();
            instancedMesh.material.dispose();
        }

        const matrices = [];
        const colorData = [];

        function subdivide(parentMatrix, depth, colorIndex) {
            if (depth >= maxDepth) return;

            const scaleMatrix = new THREE.Matrix4().makeScale(0.25, 0.25, 0.25);

            for (let i = 0; i < 8; i++) {
                const translationMatrix = new THREE.Matrix4().makeTranslation(transformations[i].x, transformations[i].y, transformations[i].z);
                const newMatrix = new THREE.Matrix4()
                    .multiply(parentMatrix)
                    .multiply(translationMatrix)
                    .multiply(scaleMatrix);

                if (depth === maxDepth - 1) {
                    matrices.push(newMatrix);
                    colorData.push(colors[i]);
                }
                
                subdivide(newMatrix, depth + 1, i);
            }
        }
        
        // Bắt đầu quá trình đệ quy từ khối lập phương gốc
        subdivide(new THREE.Matrix4(), 0, -1);

        // --- TẠO INSTANCEDMESH ---
        const geometry = new THREE.BoxGeometry(1, 1, 1);
        const material = new THREE.MeshStandardMaterial({ metalness: 0.1, roughness: 0.6 });
        
        const count = matrices.length;
        if (count === 0) return; // Tránh lỗi khi count = 0
        
        instancedMesh = new THREE.InstancedMesh(geometry, material, count);

        for (let i = 0; i < count; i++) {
            instancedMesh.setMatrixAt(i, matrices[i]);
            instancedMesh.setColorAt(i, colorData[i]);
        }
        
        scene.add(instancedMesh);
        cubeCountDisplay.textContent = `Số khối: ${count.toLocaleString('vi-VN')}`;
    }
    
    // --- VÒNG LẶP ANIMATION ---
    function animate() {
        requestAnimationFrame(animate);
        controls.update();
        renderer.render(scene, camera);
    }

    // --- XỬ LÝ SỰ KIỆN ---
    depthSlider.addEventListener('input', () => {
        const depth = parseInt(depthSlider.value);
        depthValueDisplay.textContent = depth;
        generateFractal(depth);
    });

    window.addEventListener('resize', () => {
        camera.aspect = sceneContainer.clientWidth / sceneContainer.clientHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(sceneContainer.clientWidth, sceneContainer.clientHeight);
    });

    // --- CHẠY LẦN ĐẦU ---
    generateFractal(parseInt(depthSlider.value));
    animate();
</script>

</body>
</html>